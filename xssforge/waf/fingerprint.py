"""
WAF fingerprinting for XSSForge.

Detects and identifies Web Application Firewalls.
"""

import re
from dataclasses import dataclass
from enum import Enum


class WAFType(Enum):
    """Known WAF types."""
    CLOUDFLARE = "cloudflare"
    AKAMAI = "akamai"
    AWS_WAF = "aws_waf"
    MODSECURITY = "modsecurity"
    IMPERVA = "imperva"
    SUCURI = "sucuri"
    F5_BIG_IP = "f5_bigip"
    BARRACUDA = "barracuda"
    FORTINET = "fortinet"
    CITRIX = "citrix"
    AZURE_WAF = "azure_waf"
    CLOUDFRONT = "cloudfront"
    FASTLY = "fastly"
    INCAPSULA = "incapsula"
    WORDFENCE = "wordfence"
    UNKNOWN = "unknown"
    NONE = "none"


@dataclass
class WAFSignature:
    """WAF detection signature."""
    waf_type: WAFType
    headers: dict[str, str | re.Pattern]
    cookies: list[str]
    body_patterns: list[str | re.Pattern]
    status_codes: list[int]


@dataclass
class WAFDetectionResult:
    """Result of WAF detection."""
    detected: bool
    waf_type: WAFType
    confidence: float  # 0.0 to 1.0
    evidence: list[str]


class WAFDetector:
    """Detects and fingerprints WAFs."""

    SIGNATURES: list[WAFSignature] = [
        WAFSignature(
            waf_type=WAFType.CLOUDFLARE,
            headers={
                "server": re.compile(r"cloudflare", re.I),
                "cf-ray": re.compile(r".+"),
                "cf-cache-status": re.compile(r".+"),
            },
            cookies=["__cfduid", "__cf_bm", "cf_clearance"],
            body_patterns=[
                r"Attention Required! \| Cloudflare",
                r"cloudflare-nginx",
                r"cf-error-details",
            ],
            status_codes=[403, 503, 520, 521, 522, 523, 524],
        ),
        WAFSignature(
            waf_type=WAFType.AKAMAI,
            headers={
                "server": re.compile(r"AkamaiGHost", re.I),
                "x-akamai-transformed": re.compile(r".+"),
            },
            cookies=["akamai_", "ak_bmsc", "bm_sv"],
            body_patterns=[
                r"Access Denied",
                r"Reference #\d+\.\w+\.\w+",
                r"akamaierror",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.AWS_WAF,
            headers={
                "x-amzn-requestid": re.compile(r".+"),
                "x-amz-cf-id": re.compile(r".+"),
            },
            cookies=["awsalb", "awsalbcors"],
            body_patterns=[
                r"AWS WAF",
                r"Request blocked",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.MODSECURITY,
            headers={
                "server": re.compile(r"mod_security|NOYB", re.I),
            },
            cookies=[],
            body_patterns=[
                r"Mod_Security",
                r"NOYB",
                r"This error was generated by Mod_Security",
                r"rules triggered by this request",
                r"not acceptable",
            ],
            status_codes=[403, 406, 501],
        ),
        WAFSignature(
            waf_type=WAFType.IMPERVA,
            headers={
                "x-iinfo": re.compile(r".+"),
                "x-cdn": re.compile(r"Incapsula", re.I),
            },
            cookies=["incap_ses_", "visid_incap_", "nlbi_"],
            body_patterns=[
                r"Incapsula incident ID",
                r"_Incapsula_Resource",
                r"Request unsuccessful",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.SUCURI,
            headers={
                "x-sucuri-id": re.compile(r".+"),
                "server": re.compile(r"Sucuri", re.I),
                "x-sucuri-cache": re.compile(r".+"),
            },
            cookies=["sucuri_"],
            body_patterns=[
                r"Sucuri Website Firewall",
                r"Access Denied - Sucuri Website Firewall",
                r"sucuri\.net/privacy",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.F5_BIG_IP,
            headers={
                "server": re.compile(r"BIG-?IP", re.I),
                "x-wa-info": re.compile(r".+"),
            },
            cookies=["BIGipServer", "TS", "F5_"],
            body_patterns=[
                r"The requested URL was rejected",
                r"BIG-IP",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.BARRACUDA,
            headers={
                "server": re.compile(r"Barracuda", re.I),
            },
            cookies=["barra_counter_session"],
            body_patterns=[
                r"Barracuda",
                r"barra_counter_session",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.FORTINET,
            headers={
                "server": re.compile(r"FortiWeb|FortiGate", re.I),
            },
            cookies=["FORTIWAFSID"],
            body_patterns=[
                r"FortiGuard",
                r"FortiWeb",
                r"The page cannot be displayed",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.WORDFENCE,
            headers={},
            cookies=["wfvt_", "wordfence_"],
            body_patterns=[
                r"wordfence",
                r"This response was generated by Wordfence",
                r"Your access to this site has been limited",
            ],
            status_codes=[403, 503],
        ),
        WAFSignature(
            waf_type=WAFType.AZURE_WAF,
            headers={
                "x-azure-ref": re.compile(r".+"),
            },
            cookies=[],
            body_patterns=[
                r"Azure Application Gateway",
                r"azure\.com",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.CLOUDFRONT,
            headers={
                "x-amz-cf-id": re.compile(r".+"),
                "x-amz-cf-pop": re.compile(r".+"),
                "via": re.compile(r"CloudFront", re.I),
            },
            cookies=[],
            body_patterns=[
                r"CloudFront",
                r"Request blocked",
            ],
            status_codes=[403],
        ),
        WAFSignature(
            waf_type=WAFType.FASTLY,
            headers={
                "x-fastly-request-id": re.compile(r".+"),
                "via": re.compile(r"Fastly", re.I),
            },
            cookies=[],
            body_patterns=[
                r"Fastly error:",
                r"fastly\.com",
            ],
            status_codes=[403, 503],
        ),
    ]

    def detect(
        self,
        status_code: int,
        headers: dict[str, str],
        body: str,
        cookies: dict[str, str] | None = None,
    ) -> WAFDetectionResult:
        """Detect WAF from response."""
        best_match: WAFDetectionResult | None = None
        highest_confidence = 0.0

        for sig in self.SIGNATURES:
            confidence, evidence = self._check_signature(
                sig, status_code, headers, body, cookies or {}
            )

            if confidence > highest_confidence:
                highest_confidence = confidence
                best_match = WAFDetectionResult(
                    detected=True,
                    waf_type=sig.waf_type,
                    confidence=confidence,
                    evidence=evidence,
                )

        if best_match and best_match.confidence >= 0.3:
            return best_match

        return WAFDetectionResult(
            detected=False,
            waf_type=WAFType.NONE,
            confidence=0.0,
            evidence=[],
        )

    def _check_signature(
        self,
        sig: WAFSignature,
        status_code: int,
        headers: dict[str, str],
        body: str,
        cookies: dict[str, str],
    ) -> tuple[float, list[str]]:
        """Check a single WAF signature."""
        score = 0.0
        evidence = []
        max_score = 0.0

        # Check headers (high weight)
        if sig.headers:
            max_score += 0.4
            for header_name, pattern in sig.headers.items():
                header_value = headers.get(header_name, "")
                if not header_value:
                    # Try case-insensitive lookup
                    for k, v in headers.items():
                        if k.lower() == header_name.lower():
                            header_value = v
                            break

                if header_value:
                    if isinstance(pattern, re.Pattern):
                        if pattern.search(header_value):
                            score += 0.4 / len(sig.headers)
                            evidence.append(f"Header {header_name}: {header_value}")
                    elif pattern.lower() in header_value.lower():
                        score += 0.4 / len(sig.headers)
                        evidence.append(f"Header {header_name}: {header_value}")

        # Check cookies (medium weight)
        if sig.cookies:
            max_score += 0.2
            cookie_str = str(cookies) + headers.get("set-cookie", "")
            for cookie_name in sig.cookies:
                if cookie_name.lower() in cookie_str.lower():
                    score += 0.2 / len(sig.cookies)
                    evidence.append(f"Cookie: {cookie_name}")

        # Check body patterns (high weight)
        if sig.body_patterns:
            max_score += 0.3
            for pattern in sig.body_patterns:
                if isinstance(pattern, re.Pattern):
                    if pattern.search(body):
                        score += 0.3 / len(sig.body_patterns)
                        evidence.append(f"Body pattern: {pattern.pattern[:50]}")
                elif pattern.lower() in body.lower():
                    score += 0.3 / len(sig.body_patterns)
                    evidence.append(f"Body contains: {pattern[:50]}")

        # Check status codes (low weight but confirmatory)
        if sig.status_codes:
            max_score += 0.1
            if status_code in sig.status_codes:
                score += 0.1
                evidence.append(f"Status code: {status_code}")

        # Normalize score
        if max_score > 0:
            confidence = min(score / max_score * 1.5, 1.0)  # Slight boost
        else:
            confidence = 0.0

        return confidence, evidence

    def detect_from_response(self, response) -> WAFDetectionResult:
        """Detect WAF from an HTTPResponse object."""
        return self.detect(
            status_code=response.status_code,
            headers=response.headers,
            body=response.body,
        )


def detect_waf(
    status_code: int,
    headers: dict[str, str],
    body: str,
) -> WAFDetectionResult:
    """Convenience function to detect WAF."""
    detector = WAFDetector()
    return detector.detect(status_code, headers, body)
